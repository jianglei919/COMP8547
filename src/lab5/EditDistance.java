package lab5;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.*;

public class EditDistance {

    // Function to calculate the Edit Distance between two words
    public static int calculateEditDistance(String word1, String word2) {
        int len1 = word1.length();
        int len2 = word2.length();

        // Create a DP table to store the results of subproblems
        int[][] dp = new int[len1 + 1][len2 + 1];

        // Fill dp[][] in a bottom-up manner
        for (int i = 0; i <= len1; i++) {
            for (int j = 0; j <= len2; j++) {
                // If the first word is empty, insert all characters of the second word
                if (i == 0) {
                    dp[i][j] = j; // j insertions
                }
                // If the second word is empty, remove all characters of the first word
                else if (j == 0) {
                    dp[i][j] = i; // i deletions
                }
                // If the last characters of both words are the same, ignore the last character
                // and recur for the remaining words
                else if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1];
                }
                // If the last characters are different, consider all possibilities:
                // insert, delete, or replace the last character
                else {
                    dp[i][j] = 1 + Math.min(dp[i - 1][j], // Remove
                            Math.min(dp[i][j - 1],    // Insert
                                    dp[i - 1][j - 1])); // Replace
                }
            }
        }

        // The final value in dp[len1][len2] will be the answer
        return dp[len1][len2];
    }

    // ====== Task 1 ======
    private static final int[] LENGTHS = {10, 50, 100};
    private static final int[] PAIR_COUNTS = {100, 1000};
    private static final long RNG_SEED = 20251008L; // fixed seed
    private static final Random RNG = new Random(RNG_SEED);

    /**
     * Generates a random lowercase string consisting only of letters 'a' to 'z'.
     *
     * @param len the desired length of the generated string
     * @return a random string of lowercase alphabetic characters
     * <p>
     * Explanation:
     * - A character array of length 'len' is created.
     * - Each position in the array is filled with a random character between 'a' and 'z'.
     * - The random index is generated by RNG.nextInt(26), which returns a number from 0 to 25.
     * - Adding this number to the ASCII code of 'a' yields a random lowercase letter.
     * - Finally, the character array is converted into a String and returned.
     */
    private static String randomLowercase(int len) {
        char[] cs = new char[len];                    // Create a character array of the specified length
        for (int i = 0; i < len; i++) {
            cs[i] = (char) ('a' + RNG.nextInt(26));   // Generate a random letter between 'a' and 'z'
        }
        return new String(cs);                        // Convert the character array into a String
    }

    /**
     * Measures the average CPU time (in microseconds) required to compute
     * the Edit Distance between pairs of randomly generated lowercase strings.
     *
     * <p>This method performs the following steps:</p>
     * <ol>
     *   <li>Generates two arrays of random lowercase strings (each of length {@code len}).</li>
     *   <li>Computes the edit distance for every pair using {@code calculateEditDistance()}.</li>
     *   <li>Uses {@code System.nanoTime()} to measure the total execution time.</li>
     *   <li>Returns the average time per pair in microseconds.</li>
     * </ol>
     *
     * @param len       the length of each generated string
     * @param pairCount the number of random string pairs to test
     * @return the average execution time per pair (in microseconds)
     */
    private static double benchmarkAvgMicros(int len, int pairCount) {
        // Step 1: Generate random string pairs for testing
        String[] a = new String[pairCount];
        String[] b = new String[pairCount];
        for (int i = 0; i < pairCount; i++) {
            a[i] = randomLowercase(len);   // Generate first random string
            b[i] = randomLowercase(len);   // Generate second random string
        }

        // Step 2: Measure total execution time for all pairs
        long t0 = System.nanoTime();       // Record start time (in nanoseconds)
        long sink = 0;                     // Accumulator variable to prevent JIT optimization
        for (int i = 0; i < pairCount; i++) {
            sink += calculateEditDistance(a[i], b[i]); // Compute edit distance for each pair
        }
        long t1 = System.nanoTime();       // Record end time (in nanoseconds)

        // Step 3: Optional safeguard to prevent compiler optimization from removing computation
        if (sink == Long.MIN_VALUE) {
            System.out.println("ignore: " + sink);
        }

        // Step 4: Compute the average time per pair (convert nanoseconds → microseconds)
        double totalMicros = (t1 - t0) / 1000.0;   // Total time in microseconds
        double avgMicros = totalMicros / pairCount; // Average time per pair

        // Step 5: Return the computed average time
        return avgMicros;
    }

    private static void runBenchmarks() {
        System.out.println("TASK 1: Benchmark random lowercase letters");

        // print table header
        System.out.println("=========== AVERAGE CPU TIME PER PAIR (microseconds) ===============");
        StringBuilder header = new StringBuilder();
        header.append(String.format("%-14s", "Pairs"));
        for (int len : LENGTHS) {
            header.append(String.format("%18s", "length=" + len));
        }
        System.out.println(header);
        System.out.println("--------------------------------------------------------------------");

        // matched results
        for (int pairs : PAIR_COUNTS) {
            StringBuilder row = new StringBuilder();
            row.append(String.format("%-14d", pairs));
            for (int len : LENGTHS) {
                double avg = benchmarkAvgMicros(len, pairs);
                row.append(String.format("%18.3f", avg));
            }
            System.out.println(row);
        }
        System.out.println("====================================================================");
    }

    // ====== Task 2: Dictionary loading and closest match finding ======

    /**
     * Loads a dictionary file and returns a list of valid words (lowercase letters only).
     * <p>
     * This method first attempts to locate the dictionary file at the given path.
     * If the file does not exist, it tries an alternative path "src/lab5/" + path.
     * If the file is still not found, it returns an empty list.
     * </p>
     *
     * @param path the dictionary file name (e.g., "words.txt")
     * @return a list of valid lowercase words; empty list if the file is missing or invalid
     */
    private static List<String> loadDictionary(String path) {
        try {
            // Try to locate the dictionary file in the current working directory
            Path p = Paths.get(path);
            if (!Files.exists(p)) {
                // If not found, try to locate it in the "src/lab5" folder
                p = Paths.get("src/lab5/" + path);
                if (!Files.exists(p)) {
                    return Collections.emptyList(); // Return an empty list if file not found
                }
            }

            // Read all lines from the file
            List<String> lines = Files.readAllLines(p);
            List<String> words = new ArrayList<>(lines.size());

            // Filter and normalize each line
            for (String line : lines) {
                if (line == null) continue;
                String w = line.trim().toLowerCase(Locale.ROOT);

                // Keep only non-empty words containing letters (a–z) only
                if (!w.isEmpty() && w.chars().allMatch(ch -> ch >= 'a' && ch <= 'z')) {
                    words.add(w);
                }
            }
            return words;
        } catch (IOException e) {
            System.out.println("[Error] Failed to read dictionary: " + e.getMessage());
            return Collections.emptyList();
        }
    }

    /**
     * Finds the closest match(es) to a misspelled word within a given dictionary list.
     * <p>
     * The method computes the Edit Distance between the input word and each word
     * in the dictionary, and returns all words that have the smallest distance.
     * </p>
     *
     * @param miss the misspelled input word
     * @param dict the dictionary list of valid words
     * @return a Result object containing the smallest edit distance and the closest matches
     */
    private static Result closestMatches(String miss, List<String> dict) {
        int best = Integer.MAX_VALUE;
        List<String> list = new ArrayList<>();

        // Iterate through all words in the dictionary and compute edit distance
        for (String d : dict) {
            int dist = calculateEditDistance(miss, d);
            if (dist < best) {
                best = dist;
                list.clear();
                list.add(d);
            } else if (dist == best) {
                list.add(d);
            }
        }
        return new Result(best, list);
    }

    /**
     * Demonstrates Task 2: loads the dictionary and performs closest word matching.
     * <p>
     * - Attempts to load the dictionary from the given file path.
     * - Displays the closest match for a sample or user-provided input word.
     * - Allows optional user input for additional spell-check queries.
     * </p>
     *
     * @param dictPath the path to the dictionary file (e.g., "words.txt")
     * @param demoWord the initial test word (e.g., "appel")
     */
    private static void runDictionaryDemo(String dictPath, String demoWord) {
        List<String> dict = loadDictionary(dictPath);
        System.out.println("\n========================= TASK 2: Dictionary =======================");

        // If the dictionary file is missing or empty, print a hint and stop
        if (dict.isEmpty()) {
            System.out.println("[Hint] Dictionary file not found or empty: " + dictPath);
            System.out.println("Put words.txt (one word per line, letters only) next to the program.");
            return;
        }

        // Default demo input if none is provided (based on the assignment example)
        if (demoWord == null || demoWord.isEmpty()) demoWord = "appel";

        // Compute and print the closest match(es)
        Result demo = closestMatches(demoWord.toLowerCase(Locale.ROOT), dict);
        System.out.println("Input : \"" + demoWord + "\"");
        System.out.println("Closest match(es): " + demo.matches);
        System.out.println("Edit Distance    : " + demo.distance);

        // Optional interactive section for user spell-checking
        System.out.println("[Optional] Enter a word (letters only) to query closest matches. Empty line to exit.");
        System.out.println("====================================================================");

        try (Scanner sc = new Scanner(System.in)) {
            while (true) {
                System.out.print("Query> ");
                String line = sc.nextLine();
                if (line == null) break;
                line = line.trim();
                if (line.isEmpty()) break;

                String w = line.toLowerCase(Locale.ROOT);

                // Validate input: only allow lowercase letters
                if (!w.chars().allMatch(ch -> ch >= 'a' && ch <= 'z')) {
                    System.out.println("Letters only (a..z). Try again.");
                    continue;
                }

                // Compute and print the closest match(es) for user input
                Result r = closestMatches(w, dict);
                System.out.println("Closest match(es): " + r.matches);
                System.out.println("Edit Distance    : " + r.distance);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private record Result(int distance, List<String> matches) {
    }

    public static void main(String[] args) {
        // Task 1
        runBenchmarks();

        // Task 2
        String dictPath = (args.length >= 1) ? args[0] : "words.txt";
        String demoWord = (args.length >= 2) ? args[1] : "appel";
        runDictionaryDemo(dictPath, demoWord);
    }
}