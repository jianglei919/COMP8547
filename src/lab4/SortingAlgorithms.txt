    public static void main(String[] args) {
        // ====== Lab：Multiple experiments, take the average ======
        final int[] SIZES = {100, 10_000, 120_000};   // “100,000+” 选 120,000
        final int TRIALS = 7;

        // For each input size, define the random interval parameters:
        // min ∈ [minMin, minMax]; width ∈ [widthMin, widthMax]; value range = [min, min + width]
        final int[][] RANGE_PARAMS = new int[][]{
                {0, 100, 100, 1000},             // n=100; small random range
                {0, 10_000, 10_000, 100_000},    // n=10,000; medium random range
                {0, 100_000, 100_000, 500_000}   // n=120,000 (max value ≤ ~600k, safe for Counting Sort)
        };

        final String[] ALG_NAMES = {
                "Merge Sort", "Quicksort", "In-place Quick", "Heapsort", "Counting Sort", "Radix Sort"
        };

        // avgMs[k][s] stores the average time (ms) for algorithm k with size SIZES[s]
        double[][] avgMs = new double[ALG_NAMES.length][SIZES.length];

        java.util.Random random = new java.util.Random();

        // Iterate over each input size
        for (int s = 0; s < SIZES.length; s++) {
            int size = SIZES[s];
            int minMin = RANGE_PARAMS[s][0];
            int minMax = RANGE_PARAMS[s][1];
            int widthMin = RANGE_PARAMS[s][2];
            int widthMax = RANGE_PARAMS[s][3];

            // Accumulate total nanoseconds for each algorithm across all trials
            long[] sumNs = new long[ALG_NAMES.length];

            // Perform multiple trials; each trial uses a new random range and dataset
            for (int t = 0; t < TRIALS; t++) {
                // Randomly select interval [min, max] for this trial
                int min = minMin + random.nextInt(Math.max(1, (minMax - minMin + 1)));
                int width = widthMin + random.nextInt(Math.max(1, (widthMax - widthMin + 1)));
                int max = min + width;

                // Generate the base random array for this trial
                long[] base = new long[size];
                for (int i = 0; i < size; i++) {
                    base[i] = min + random.nextInt(Math.max(1, (max - min + 1)));
                }

                // 1. Merge Sort
                {
                    long[] a = base.clone();
                    long t0 = System.nanoTime();
                    mergeSort(a, 0, a.length - 1);
                    long t1 = System.nanoTime();
                    sumNs[0] += (t1 - t0);
                    // Check if the sorting result is correct
                    long[] g = base.clone();
                    java.util.Arrays.sort(g);
                    if (!java.util.Arrays.equals(a, g)) throw new AssertionError("Merge Sort wrong.");
                }
                // 2. Quicksort
                {
                    long[] a = base.clone();
                    long t0 = System.nanoTime();
                    quickSort(a, 0, a.length - 1);
                    long t1 = System.nanoTime();
                    sumNs[1] += (t1 - t0);
                    long[] g = base.clone();
                    java.util.Arrays.sort(g);
                    if (!java.util.Arrays.equals(a, g)) throw new AssertionError("Quicksort wrong.");
                }
                // 3. In-place Quicksort
                {
                    long[] a = base.clone();
                    long t0 = System.nanoTime();
                    inPlaceQuickSort(a, 0, a.length - 1);
                    long t1 = System.nanoTime();
                    sumNs[2] += (t1 - t0);
                    long[] g = base.clone();
                    java.util.Arrays.sort(g);
                    if (!java.util.Arrays.equals(a, g)) throw new AssertionError("In-place Quicksort wrong.");
                }
                // 4. Heapsort
                {
                    long[] a = base.clone();
                    long t0 = System.nanoTime();
                    heapSort(a, a.length);
                    long t1 = System.nanoTime();
                    sumNs[3] += (t1 - t0);
                    long[] g = base.clone();
                    java.util.Arrays.sort(g);
                    if (!java.util.Arrays.equals(a, g)) throw new AssertionError("Heapsort wrong.");
                }
                // 5. Counting Sort（only nonnegative integer）
                {
                    long[] a = base.clone();
                    long t0 = System.nanoTime();
                    countSort(a, a.length);
                    long t1 = System.nanoTime();
                    sumNs[4] += (t1 - t0);
                    long[] g = base.clone();
                    java.util.Arrays.sort(g);
                    if (!java.util.Arrays.equals(a, g)) throw new AssertionError("Counting Sort wrong.");
                }
                // 6. Radix Sort（only nonnegative integer）
                {
                    long[] a = base.clone();
                    long t0 = System.nanoTime();
                    radixsort(a, a.length);
                    long t1 = System.nanoTime();
                    sumNs[5] += (t1 - t0);
                    long[] g = base.clone();
                    java.util.Arrays.sort(g);
                    if (!java.util.Arrays.equals(a, g)) throw new AssertionError("Radix Sort wrong.");
                }
            }

            // average value（to millisecond）
            for (int k = 0; k < ALG_NAMES.length; k++) {
                avgMs[k][s] = sumNs[k] / (double) TRIALS / 1_000_000.0;
            }
        }

        // print result
        System.out.println();
        System.out.println("============================ AVERAGE TIME (ms) ============================");
        System.out.printf("%-18s %16s %18s %18s%n", "Algorithm", "size = 100", "size = 10,000", "size = 120,000");
        System.out.println("---------------------------------------------------------------------------");
        for (int k = 0; k < ALG_NAMES.length; k++) {
            System.out.printf("%-18s %16.3f %18.3f %18.3f%n",
                    ALG_NAMES[k], avgMs[k][0], avgMs[k][1], avgMs[k][2]);
        }
        System.out.println("===========================================================================");
    }